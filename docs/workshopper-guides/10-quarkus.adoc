So you have by now learnt how Red Hat SSO works, how to deploy a Spring app and alot more. Now its time to learn how Quarkus can secure your applications. 
In this excercise we are going to bring back our JS Console, and add some end points so that we can communicate between the front end Java script client and the backend. 

In this example, we build a very simple microservice which offers two endpoints:

<1> /api/person

<2> /api/admin

These endpoints are protected and can only be accessed if a client is sending a bearer token along with the request, which must be valid (e.g.: signature, expiration and audience) and trusted by the microservice. We will configure this in our keycloak server to ensure that backend services can be reached from the front end JS Console. The bearer token is issued by a Keycloak Server and represents the subject to which the token was issued for. For being an OAuth 2.0 Authorization Server, the token also references the client acting on behalf of the user.

- The /api/person endpoint can be accessed by any user with a with a valid token. 

- The /api/admin as the name denotes can only be accessed by admin users.

Lets start by first creating a new openshift project. 
[source, bash]
----
oc new-project <evalsXX>-quarkus
----


Lets create a new keycloak application
- Open the template.json file in the directory keycloak.

- Copy the contents of the template file

- Goto the openshift console and press the `add to project` button and then `Import YAML/JSON`

- Paste the content and press next.

- Ensure the following parameters are filled in:
<1> Keycloak Administrator Password

<2> Keycloak Administrator Password

<3> Namespace used for DNS discovery : this is your development project for quarkus which should be something like this: e.g. evals01-quarkus 

And then press create

image::keycloak_create.png[Keycloak Template]

Wait for the installation to be finished. 

Perfect now we have the keycloak running. Lets login with our admin user account. 
And lets create a new realm. 
In the keycloak directory is a realm file, you should load that file when creating a new realm. It will load all the necessary settings. 
Once loaded, it will show you a success message. 

Perfect now we have keycloak all set for our applicaiton. Lets go ahead and make one. 
We have already added a sample project `security-openid-connect-quickstart` its a quick start project with some code already provided. We will review this code and make some changes to it and finally deploy it.

Here is our configuration file for our application: 
[source, properties]
----
quarkus.oidc.auth-server-url=http://localhost:8180/auth/realms/quarkus <1>
quarkus.oidc.client-id=backend-service <2>
quarkus.oidc.credentials.secret=secret <3>

# DEBUG console logging
quarkus.log.console.enable=true
#quarkus.log.console.format=%d{HH:mm:ss} %-5p [%c{2.}]] (%t) %s%e%n
#quarkus.log.console.level=DEBUG

# TRACE file logging
quarkus.log.file.enable=true
#quarkus.log.file.path=/tmp/trace.log
quarkus.log.file.level=TRACE
quarkus.log.file.format=%d{HH:mm:ss} %-5p [%c{2.}]] (%t) %s%e%n
quarkus.log.category."io.quarkus.smallrye.jwt".level=TRACE
quarkus.log.category."io.undertow.request.security".level=TRACE
quarkus.log.category."io.smallrye.jwt".level=TRACE

----

<1> Change the value of the property `quarkus.oidc.auth-server-url` to the newly deployed keycloak server url

<2> this is the Client name in our keycloak server, quite similar to our JS Console app in our previous excercise which was called `js-console`

<3> Since this is a backend service, it also use credentials, anyone without these credentials will not be able to call the server. even if they had a from the keycloak server. this is important since we will need this in our JS Console app too.

Lets verify our Admin end point
[source, java]
----
// TODO
//@Path("/api/admin") <1>
//@Authenticated <2>
public class AdminResource {

    @GET
//    @RolesAllowed("admin") <3>
    @Produces(MediaType.TEXT_PLAIN)
    public String admin() {
        return "granted";
    }
}
----

<1> 

<2>

<3>


oc new-build registry.access.redhat.com/redhat-openjdk-18/openjdk18-openshift:1.5 --binary --name=kstart -l app=kstart

oc start-build kstart --from-file target/*-runner.jar --follow





